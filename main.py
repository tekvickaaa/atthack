from contextlib import asynccontextmanager
from typing import Annotated, List, Optional
from fastapi import FastAPI, Depends, WebSocket, HTTPException, status, BackgroundTasks
from database import Base, engine, SessionLocal
from sqlalchemy.orm import Session
from datetime import datetime
from schemas import (
    UserResponse,
    MeetingResponse,
    MeetingCreate,
    MeetingCreateResponse,
    TranscriptItem,
    TranscribeResponse,
    QuizSubmission,
    QuizSubmissionResponse,
    UserQuizAttemptResponse,
    MeetingSummaryResponse,
    QuizWithAnswers,
    QuestionWithCorrectAnswer
)
from models import User, Meeting, Transcribe
from quiz_service import QuizService


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Base.metadata.drop_all(bind=engine)
    Base.metadata.create_all(bind=engine, checkfirst=True)
    yield


app = FastAPI(lifespan=lifespan)


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


db_dependency = Annotated[Session, Depends(get_db)]


@app.get("/")
async def read_root():
    return {"Hello": "World"}


# User endpoints
@app.get("/user")
async def read_users(db: db_dependency):
    users = db.query(User).all()
    return users


@app.get("/user/{username}", response_model=UserResponse)
async def read_user(username: str, db: db_dependency):
    user = db.query(User).filter(User.username == username).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
    return user


@app.put("/user/{username}", response_model=UserResponse)
async def update_user(username: str, updated_user: UserResponse, db: db_dependency):
    pass


# Meeting endpoints
@app.post("/meeting", response_model=MeetingCreateResponse, status_code=status.HTTP_201_CREATED)
async def create_meeting(
        meeting_data: MeetingCreate,
        background_tasks: BackgroundTasks,
        db: db_dependency
):
    """
    Creates a new meeting and returns the database-generated meeting_id.
    The ID is auto-generated by the database.
    Automatically generates intro quiz in background.
    """
    new_meeting = Meeting(
        name=meeting_data.name,
        description=meeting_data.description
    )

    db.add(new_meeting)
    db.commit()
    db.refresh(new_meeting)

    # Generate intro quiz in background (non-blocking)
    async def generate_intro_quiz_task():
        try:
            # Create new DB session for background task
            db_bg = SessionLocal()
            try:
                quiz_service = QuizService(db_bg)
                await quiz_service.get_or_create_intro_quiz(new_meeting.id)
            finally:
                db_bg.close()
        except Exception as e:
            # Log error but don't fail meeting creation
            print(f"Failed to generate intro quiz for meeting {new_meeting.id}: {e}")

    background_tasks.add_task(generate_intro_quiz_task)

    return MeetingCreateResponse(
        id=new_meeting.id,
        name=new_meeting.name
    )


@app.get("/meeting/{meeting_id}", response_model=MeetingResponse)
async def get_meeting(meeting_id: int, db: db_dependency):
    meeting = db.query(Meeting).filter(Meeting.id == meeting_id).first()
    if not meeting:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Meeting not found")
    return meeting


# Transcript endpoints
@app.post("/meeting/{meeting_id}/transcripts", status_code=status.HTTP_201_CREATED)
async def create_transcripts(meeting_id: int, transcripts: List[TranscriptItem], db: db_dependency):
    """
    Receives an array of transcripts for a specific meeting_id (as URL parameter).
    Creates or updates users as needed, then saves all transcripts.
    """
    # Verify meeting exists
    meeting = db.query(Meeting).filter(Meeting.id == meeting_id).first()
    if not meeting:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Meeting with id {meeting_id} not found"
        )

    created_transcripts = []

    for transcript in transcripts:
        # Check if user exists, create if not
        user = db.query(User).filter(User.username == transcript.username).first()
        if not user:
            user = User(
                username=transcript.username,
                discord_user_id=transcript.userId
            )
            db.add(user)
            db.flush()  # Get the user ID without committing
        elif not user.discord_user_id:
            # Update discord_user_id if it wasn't set
            user.discord_user_id = transcript.userId

        # Parse timestamp
        timestamp = datetime.fromisoformat(transcript.timestamp.replace('Z', '+00:00'))

        # Create transcript
        new_transcript = Transcribe(
            user_username=user.username,
            meeting_id=meeting_id,
            transcription_text=transcript.transcription,
            timestamp=timestamp,
            guild_id=transcript.guildId,
            channel_id=transcript.channelId
        )

        db.add(new_transcript)
        created_transcripts.append(new_transcript)

    db.commit()

    # Refresh all transcripts to get their IDs
    for t in created_transcripts:
        db.refresh(t)

    return {
        "message": f"Successfully created {len(created_transcripts)} transcripts",
        "meeting_id": meeting_id,
        "transcript_count": len(created_transcripts)
    }


@app.get("/meeting/{meeting_id}/transcripts", response_model=list[TranscribeResponse])
async def get_meeting_transcripts(meeting_id: int, db: db_dependency):
    """
    Get all transcripts for a specific meeting, ordered by timestamp.
    """
    transcripts = db.query(Transcribe).filter(
        Transcribe.meeting_id == meeting_id
    ).order_by(Transcribe.timestamp.asc()).all()

    return transcripts


# ============================================================================
# QUIZ ENDPOINTS
# ============================================================================

@app.get("/meeting/{meeting_id}/intro-quiz", response_model=QuizResponse)
async def get_intro_quiz(meeting_id: int, db: db_dependency):
    """
    Get or generate intro quiz for a meeting.
    Returns quiz without correct answers.
    """
    try:
        quiz_service = QuizService(db)
        quiz = await quiz_service.get_or_create_intro_quiz(meeting_id)
        return quiz
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate intro quiz: {str(e)}"
        )


@app.get("/meeting/{meeting_id}/outro-quiz", response_model=QuizResponse)
async def get_outro_quiz(meeting_id: int, db: db_dependency):
    """
    Get or generate outro quiz for a meeting based on transcripts.
    Returns quiz without correct answers.
    Requires transcripts to exist.
    """
    try:
        quiz_service = QuizService(db)
        quiz = await quiz_service.get_or_create_outro_quiz(meeting_id)
        return quiz
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate outro quiz: {str(e)}"
        )


@app.get("/meeting/{meeting_id}/summary", response_model=MeetingSummaryResponse)
async def get_meeting_summary(meeting_id: int, db: db_dependency):
    """
    Get meeting summary (generated from outro quiz).
    Returns summary points and metadata.
    """
    quiz_service = QuizService(db)
    summary = quiz_service.get_meeting_summary(meeting_id)

    if not summary:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Meeting {meeting_id} not found"
        )

    return summary


@app.post("/quiz/{quiz_id}/submit", response_model=QuizSubmissionResponse)
async def submit_quiz(quiz_id: int, submission: QuizSubmission, db: db_dependency):
    """
    Submit quiz answers and get results.
    Returns score, correct answers, and detailed feedback.
    """
    try:
        quiz_service = QuizService(db)

        # Validate quiz exists
        quiz = quiz_service.get_quiz_by_id(quiz_id)
        if not quiz:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Quiz {quiz_id} not found"
            )

        # Convert submission to list of dicts
        answers = [
            {
                "question_id": ans.question_id,
                "selected_answer_index": ans.selected_answer_index
            }
            for ans in submission.answers
        ]

        # Submit and get results
        results = quiz_service.submit_quiz_attempt(
            quiz_id=quiz_id,
            user_username=submission.user_username,
            answers=answers
        )

        # Build response with correct answers included
        quiz_with_answers = QuizWithAnswers(
            id=quiz.id,
            meeting_id=quiz.meeting_id,
            quiz_type=quiz.quiz_type,
            summary_points=quiz.summary_points,
            generated_at=quiz.generated_at,
            questions=[
                QuestionWithCorrectAnswer(
                    id=q.id,
                    quiz_id=q.quiz_id,
                    question_text=q.question_text,
                    order=q.order,
                    correct_answer_index=q.correct_answer_index,
                    answers=q.answers
                )
                for q in quiz.questions
            ]
        )

        return QuizSubmissionResponse(
            score=results["score"],
            total_questions=results["total_questions"],
            percentage=results["percentage"],
            passed=results["passed"],
            correct_answers=results["correct_answers"],
            user_answers=results["user_answers"],
            quiz_with_answers=quiz_with_answers,
            attempt_id=results["attempt_id"]
        )

    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to submit quiz: {str(e)}"
        )


@app.get("/user/{username}/quiz-attempts", response_model=List[UserQuizAttemptResponse])
async def get_user_quiz_attempts(
        username: str,
        quiz_id: Optional[int] = None,
        db: db_dependency = Depends(get_db)
):
    """
    Get user's quiz attempt history.
    Optionally filter by quiz_id.
    """
    quiz_service = QuizService(db)
    attempts = quiz_service.get_user_attempts(username, quiz_id)

    # Add calculated fields
    response = []
    for attempt in attempts:
        response.append(
            UserQuizAttemptResponse(
                id=attempt.id,
                user_username=attempt.user_username,
                quiz_id=attempt.quiz_id,
                score=attempt.score,
                total_questions=attempt.total_questions,
                completed_at=attempt.completed_at,
                percentage=round((attempt.score / attempt.total_questions) * 100, 2),
                passed=(attempt.score / attempt.total_questions) >= 0.6
            )
        )

    return response


@app.get("/quiz/{quiz_id}", response_model=QuizResponse)
async def get_quiz(quiz_id: int, db: db_dependency):
    """
    Get quiz by ID without correct answers.
    Use this to display quiz to users before submission.
    """
    quiz_service = QuizService(db)
    quiz = quiz_service.get_quiz_by_id(quiz_id)

    if not quiz:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Quiz {quiz_id} not found"
        )

    return quiz