from contextlib import asynccontextmanager
from typing import Annotated, List, Optional
from fastapi import FastAPI, Depends, WebSocket, HTTPException, status, BackgroundTasks
from database import Base, engine, SessionLocal
from sqlalchemy.orm import Session
from datetime import datetime
from schemas import (
    UserResponse,
    MeetingResponse,
    MeetingCreate,
    MeetingCreateResponse,
    TranscriptItem,
    TranscribeResponse,
    QuizResponse,
    QuizSubmission,
    QuizSubmissionResponse,
    UserQuizAttemptResponse,
    MeetingSummaryResponse,
    QuizWithAnswers,
    QuestionWithCorrectAnswer,
    UserMeetingEvaluationResponse,
    ScoreBreakdown
)
from models import User, Meeting, Transcribe
from quiz_service import QuizService
from auth import get_current_user


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Base.metadata.drop_all(bind=engine)
    Base.metadata.create_all(bind=engine, checkfirst=True)
    yield


app = FastAPI(lifespan=lifespan)


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


db_dependency = Annotated[Session, Depends(get_db)]
current_user_dependency = Annotated[User, Depends(get_current_user)]


@app.get("/")
async def read_root():
    return {"Hello": "World"}


# User endpoints
@app.get("/user")
async def read_users(db: db_dependency):
    users = db.query(User).all()
    return users


@app.get("/user/{username}", response_model=UserResponse)
async def read_user(username: str, db: db_dependency):
    user = db.query(User).filter(User.username == username).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
    return user


@app.put("/user/{username}", response_model=UserResponse)
async def update_user(username: str, updated_user: UserResponse, db: db_dependency):
    pass


# Meeting endpoints
@app.get("/meeting", response_model=List[MeetingResponse])
async def read_meetings(db: db_dependency):
    meetings = db.query(Meeting).all()
    return meetings
@app.post("/meeting", response_model=MeetingCreateResponse, status_code=status.HTTP_201_CREATED)
async def create_meeting(
        meeting_data: MeetingCreate,
        background_tasks: BackgroundTasks,
        db: db_dependency
):
    """
    Creates a new meeting and returns the database-generated meeting_id.
    The ID is auto-generated by the database.
    Automatically generates intro quiz in background.
    """
    new_meeting = Meeting(
        name=meeting_data.name,
        description=meeting_data.description
    )

    db.add(new_meeting)
    db.commit()
    db.refresh(new_meeting)

    # Generate intro quiz in background (non-blocking)
    async def generate_intro_quiz_task():
        try:
            # Create new DB session for background task
            db_bg = SessionLocal()
            try:
                quiz_service = QuizService(db_bg)
                await quiz_service.get_or_create_intro_quiz(new_meeting.id)
            finally:
                db_bg.close()
        except Exception as e:
            # Log error but don't fail meeting creation
            print(f"Failed to generate intro quiz for meeting {new_meeting.id}: {e}")

    background_tasks.add_task(generate_intro_quiz_task)

    return MeetingCreateResponse(
        id=new_meeting.id,
        name=new_meeting.name
    )


@app.get("/meeting/{meeting_id}", response_model=MeetingResponse)
async def get_meeting(meeting_id: int, db: db_dependency):
    meeting = db.query(Meeting).filter(Meeting.id == meeting_id).first()
    if not meeting:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Meeting not found")
    return meeting


# Transcript endpoints
@app.post("/meeting/{meeting_id}/transcripts", status_code=status.HTTP_201_CREATED)
async def create_transcripts(meeting_id: int, transcripts: List[TranscriptItem], db: db_dependency):
    """
    Receives an array of transcripts for a specific meeting_id (as URL parameter).
    Creates or updates users as needed, then saves all transcripts.
    """
    # Verify meeting exists
    meeting = db.query(Meeting).filter(Meeting.id == meeting_id).first()
    if not meeting:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Meeting with id {meeting_id} not found"
        )

    created_transcripts = []

    for transcript in transcripts:
        # Check if user exists, create if not
        user = db.query(User).filter(User.username == transcript.username).first()
        if not user:
            user = User(
                username=transcript.username,
                discord_user_id=transcript.userId
            )
            db.add(user)
            db.flush()  # Get the user ID without committing
        elif not user.discord_user_id:
            # Update discord_user_id if it wasn't set
            user.discord_user_id = transcript.userId

        # Parse timestamp
        timestamp = datetime.fromisoformat(transcript.timestamp.replace('Z', '+00:00'))

        # Create transcript
        new_transcript = Transcribe(
            user_username=user.username,
            meeting_id=meeting_id,
            transcription_text=transcript.transcription,
            timestamp=timestamp,
            guild_id=transcript.guildId,
            channel_id=transcript.channelId
        )

        db.add(new_transcript)
        created_transcripts.append(new_transcript)

    db.commit()

    # Refresh all transcripts to get their IDs
    for t in created_transcripts:
        db.refresh(t)

    return {
        "message": f"Successfully created {len(created_transcripts)} transcripts",
        "meeting_id": meeting_id,
        "transcript_count": len(created_transcripts)
    }


@app.get("/meeting/{meeting_id}/transcripts", response_model=list[TranscribeResponse])
async def get_meeting_transcripts(meeting_id: int, db: db_dependency):
    """
    Get all transcripts for a specific meeting, ordered by timestamp.
    """
    transcripts = db.query(Transcribe).filter(
        Transcribe.meeting_id == meeting_id
    ).order_by(Transcribe.timestamp.asc()).all()

    return transcripts


# ============================================================================
# QUIZ ENDPOINTS
# ============================================================================

@app.get("/meeting/{meeting_id}/intro-quiz", response_model=QuizResponse)
async def get_intro_quiz(
    meeting_id: int, 
    db: db_dependency,
    current_user: current_user_dependency
):
    """
    Get or generate intro quiz for a meeting.
    Returns quiz without correct answers.
    Requires X-User-Username header for authentication.
    """
    try:
        quiz_service = QuizService(db)
        quiz = await quiz_service.get_or_create_intro_quiz(meeting_id)
        return quiz
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate intro quiz: {str(e)}"
        )


@app.get("/meeting/{meeting_id}/outro-quiz", response_model=QuizResponse)
async def get_outro_quiz(
    meeting_id: int, 
    db: db_dependency,
    current_user: current_user_dependency
):
    """
    Get or generate outro quiz for a meeting based on transcripts.
    Returns quiz without correct answers.
    Requires transcripts to exist.
    Requires X-User-Username header for authentication.
    """
    try:
        quiz_service = QuizService(db)
        quiz = await quiz_service.get_or_create_outro_quiz(meeting_id)
        return quiz
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate outro quiz: {str(e)}"
        )


@app.get("/meeting/{meeting_id}/summary", response_model=MeetingSummaryResponse)
async def get_meeting_summary(meeting_id: int, db: db_dependency):
    """
    Get meeting summary (generated from transcripts).
    Returns summary points and metadata.
    """
    quiz_service = QuizService(db)
    summary = quiz_service.get_meeting_summary(meeting_id)

    if not summary:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Meeting {meeting_id} not found"
        )

    return summary

@app.post("/meeting/{meeting_id}/summary/generate", response_model=MeetingSummaryResponse)
async def generate_meeting_summary(meeting_id: int, db: db_dependency):
    """
    Generate a new summary from meeting transcripts.
    This will analyze all transcripts and create a comprehensive summary.
    """
    try:
        quiz_service = QuizService(db)
        summary = await quiz_service.generate_meeting_summary(meeting_id)
        return summary
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to generate summary: {str(e)}"
        )

@app.post("/quiz/{quiz_id}/submit", response_model=QuizSubmissionResponse)
async def submit_quiz(
    quiz_id: int, 
    submission: QuizSubmission, 
    db: db_dependency,
    current_user: current_user_dependency
):
    """
    Submit quiz answers and get results.
    Returns score, correct answers, and detailed feedback.
    Requires X-User-Username header for authentication.
    """
    # Verify the submission is for the authenticated user
    if submission.user_username != current_user.username:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cannot submit quiz for another user"
        )
    
    try:
        quiz_service = QuizService(db)

        # Validate quiz exists
        quiz = quiz_service.get_quiz_by_id(quiz_id)
        if not quiz:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Quiz {quiz_id} not found"
            )

        # Convert submission to list of dicts
        answers = [
            {
                "question_id": ans.question_id,
                "selected_answer_index": ans.selected_answer_index
            }
            for ans in submission.answers
        ]

        # Submit and get results
        results = quiz_service.submit_quiz_attempt(
            quiz_id=quiz_id,
            user_username=submission.user_username,
            answers=answers
        )

        # Build response with correct answers included
        quiz_with_answers = QuizWithAnswers(
            id=quiz.id,
            meeting_id=quiz.meeting_id,
            quiz_type=quiz.quiz_type,
            summary_points=quiz.summary_points,
            generated_at=quiz.generated_at,
            questions=[
                QuestionWithCorrectAnswer(
                    id=q.id,
                    quiz_id=q.quiz_id,
                    question_text=q.question_text,
                    order=q.order,
                    correct_answer_index=q.correct_answer_index,
                    answers=q.answers
                )
                for q in quiz.questions
            ]
        )

        return QuizSubmissionResponse(
            score=results["score"],
            total_questions=results["total_questions"],
            percentage=results["percentage"],
            passed=results["passed"],
            correct_answers=results["correct_answers"],
            user_answers=results["user_answers"],
            quiz_with_answers=quiz_with_answers,
            attempt_id=results["attempt_id"]
        )

    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to submit quiz: {str(e)}"
        )


@app.get("/user/{username}/quiz-attempts", response_model=List[UserQuizAttemptResponse])
async def get_user_quiz_attempts(
        username: str,
        db: db_dependency,
        current_user: current_user_dependency,
        quiz_id: Optional[int] = None
):
    """
    Get user's quiz attempt history.
    Optionally filter by quiz_id.
    Requires X-User-Username header for authentication.
    """
    # Verify requesting own data
    if username != current_user.username:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cannot view another user's quiz attempts"
        )
    
    quiz_service = QuizService(db)
    attempts = quiz_service.get_user_attempts(username, quiz_id)

    # Add calculated fields
    response = []
    for attempt in attempts:
        response.append(
            UserQuizAttemptResponse(
                id=attempt.id,
                user_username=attempt.user_username,
                quiz_id=attempt.quiz_id,
                score=attempt.score,
                total_questions=attempt.total_questions,
                completed_at=attempt.completed_at,
                percentage=round((attempt.score / attempt.total_questions) * 100, 2),
                passed=(attempt.score / attempt.total_questions) >= 0.6
            )
        )

    return response


@app.get("/quiz/{quiz_id}", response_model=QuizResponse)
async def get_quiz(quiz_id: int, db: db_dependency):
    """
    Get quiz by ID without correct answers.
    Use this to display quiz to users before submission.
    """
    quiz_service = QuizService(db)
    quiz = quiz_service.get_quiz_by_id(quiz_id)

    if not quiz:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Quiz {quiz_id} not found"
        )

    return quiz


# ============================================================================
# PERFORMANCE EVALUATION ENDPOINT
# ============================================================================

@app.post("/meeting/{meeting_id}/evaluate/{username}", response_model=UserMeetingEvaluationResponse)
async def evaluate_user_performance(
    meeting_id: int, 
    username: str, 
    db: db_dependency,
    current_user: current_user_dependency
):
    """
    Generate performance evaluation for a user in a specific meeting.
    Evaluates based on:
    - Outro quiz score (0-30 points)
    - Participation quality (0-50 points) - AI analyzes transcript relevance
    - Engagement level (0-20 points) - AI evaluates contribution quantity
    
    Total score: 0-100 points
    - Adds score to user's credits
    - Updates user's rolling average score
    - Can only be run once per user-meeting combination
    Requires X-User-Username header for authentication.
    """
    # Verify the evaluation is for the authenticated user
    if username != current_user.username:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cannot evaluate another user"
        )
    
    try:
        quiz_service = QuizService(db)
        result = await quiz_service.evaluate_user_performance(meeting_id, username)
        
        return UserMeetingEvaluationResponse(
            meeting_id=result["meeting_id"],
            meeting_name=result["meeting_name"],
            username=result["username"],
            evaluation_score=result["evaluation_score"],
            strengths=result["strengths"],
            weaknesses=result["weaknesses"],
            tips=result["tips"],
            breakdown=ScoreBreakdown(
                quiz_score=result["breakdown"]["quiz_score"],
                participation_score=result["breakdown"]["participation_score"],
                quality_score=result["breakdown"]["quality_score"]
            ),
            meetings_attended=result["meetings_attended"],
            updated_user_score=result["updated_user_score"],
            credits_earned=result["credits_earned"],
            evaluated_at=result["evaluated_at"]
        )
    except ValueError as e:
        # Handle specific error cases
        error_msg = str(e)
        if "already been evaluated" in error_msg:
            raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=error_msg)
        elif "not found" in error_msg or "has no transcripts" in error_msg or "has not completed" in error_msg:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=error_msg)
        else:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=error_msg)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to evaluate user performance: {str(e)}"
        )